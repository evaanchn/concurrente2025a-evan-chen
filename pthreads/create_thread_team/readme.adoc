= Team shot put
:experimental:
:nofooter:
:source-highlighter: pygments
:sectnums:
:stem: latexmath
:toc:
:xrefstyle: short

Suponga que dos equipos se enfrentan en el deporte de lanzamiento de bala (_shot put_). Cada equipo tiene la misma cantidad de atletas. Los atletas de cada equipo se ordenan y se enfrentan en parejas. Para simplificar, la notación `T.N` indica el atleta número `N` del equipo `T`. Por ejemplo, el atleta 1 del equipo 1 se enfrenta con el atleta 1 del equipo 2 (`1.1 vs 2.1`), y el atleta N del equipo 1 se enfrenta con el atleta N del equipo 2 (`1.N vs 2.N`).

Cada atleta dispone de tres lanzamientos y se toma la distancia más larga que consiguió llegar la bala (_shot_) en esos tres tiros. Si el atleta `N` de un equipo consigue llegar la bala más largo que su par `N` del otro equipo, consigue un punto para su equipo. Gana el encuentro el equipo que consigue más puntos. Los equipos siempre tienen una cantidad impar de atletas.

Simule la situación anterior con programación concurrente. El hilo principal realiza el rol del árbitro. El hilo principal obtiene la cantidad de atletas por argumento de línea de comandos, que siempre debe proveerse y ser impar, de lo contrario, finaliza con un mensaje de error. Seguidamente crea dos equipos de la misma cantidad de atletas (hilos secundarios).

Cada atleta lanza la bala tres veces, lo cual se puede simular generando tres números pseudoaleatorios, tomar el mayor de ellos, imprimirlo en la salida estándar, y reportarlo al árbitro como su valor de retorno. Un lanzamiento se mide como una distancia real entre 0.0 y 25.0 metros. Para comunicar este resultado al árbitro, podría implementar una estrategia como las siguientes.

. Dado que un flotante de doble precisión tiene el mismo tamaño que un puntero en una arquitectura de 64 bits, puede retornar su valor como una dirección de memoria.
. Usar memoria dinámica para alojar el resultado del mejor lanzamiento y retornar la dirección al árbitro.
. El árbitro crea una pizarra donde los atletas anotan su mejor resultado.

El árbitro se encargará de comparar los resultados de cada pareja de atletas, contar los puntos, y reportar en la salida estándar el equipo ganador. La siguiente podría ser una interación con la simulación.

[source,sh]
----
$ bin/team_shot_put 2
error: athlete count must be odd

$ bin/team_shot_put 3
2.1: best shot put 18.407m
1.1: best shot put 11.913m
1.3: best shot put 22.105m
2.2: best shot put 7.890m
2.3: best shot put 24.681m
1.2: best shot put 14.009m
result 1:2, team 2 wins
----

Se introducen dos procedimientos al pseudocódigo para crear y esperar por equipos de hilos:

[source, pascal]
----
procedure main():
  shared thread_count := 5
  declare team := create_threads(thread_count, routine)
  ...
  join_threads(team)
end procedure

procedure routine(thread_number)
  print("I am thread ", thread_number, " of ", thread_count)
----

El procedimiento create_threads() crea un equipo de hilos, todos ejecutando el procedimiento routine() concurrentemente, y retorna un arreglo de valores que representan hilos de ejecución. De forma análoga, el procedimiento join_threads() recibe el arreglo de hilos y espera a que todos ellos finalicen su ejecución.

Contar con estos dos procedimientos reutilizables es sumamente útil para la implementación de equipos de hilos en el paralelismo de datos. Las siguientes son implementaciones iniciales usando Pthreads:

[source, c]
----
pthread_t* create_threads(size_t count, void*(*routine)(void*), void* data) {
  pthread_t* threads = (pthread_t*) calloc(count, sizeof(pthread_t));
  if (threads) {
    for (size_t index = 0; index < count; ++index) {
      if (pthread_create(&threads[index], NULL, routine, data) != 0) {
        fprintf(stderr, "error: could not create thread %zu\n", index);
        join_threads(index, threads);
        return NULL;
      }
    }
  }
  return threads;
}

int join_threads(size_t count, pthread_t* threads) {
  int error_count = 0;
  for (size_t index = 0; index < count; ++index) {
    const int error = pthread_join(threads[index], NULL);
    if (error) {
      fprintf(stderr, "error: could not join thread %zu\n", index);
      ++error_count;
    }
  }
  free(threads);
  return error_count;
}
----

Las implementaciones anteriores no proveen a los hilos secundarios su número de hilo en el equipo. Modifique la subrutina create_threads() para que cree en la memoria dinámica e inicialice un arreglo de registros de datos privados. Cada registro tiene cuatro valores: el número de hilo (obtenido del índice de un ciclo), la cantidad de hilos en el equipo de hilos, el puntero a los datos compartidos (data, recibido por parámetro), y el identificador del hilo (pthread_t) inicializado con pthread_create(). Envíe la dirección del registro privado a cada hilo al crearlo con pthread_create(). Finalmente create_threads() retorna la dirección de este arreglo de registros privados en lugar del arreglo de identificadores de hilos (pthread_t).

Modifique a join_threads() para que reciba la cantidad de hilos y la dirección al arreglo de registros privados (en lugar del arreglo de identificadores de hilos). Luego esperará por cada hilo con pthread_join() usando el identificador del hilo en los datos privados. Finalmente libera el arreglo de datos privados.

Con estos cambios, los hilos podrán saber su número de hilo (thread_number) y la cantidad de hilos que hay en el equipo (thread_count) accediendo a los campos del registro privado.

