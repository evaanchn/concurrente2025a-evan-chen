struct shared_data
  declare plate_matrix
  declare thread_count
  declare stop_condition
  declare rows_queue
  declare mult_constant
  declare epsilon
  declare equilibrated_plate
  declare semaphore can_get_working_row
  declare semaphore state_done
  declare mutex can_access_equilibrated

struct private_data
  declare thread_id
  declare shared_data

function init_shared_data(shared_data, thread_count)
  shared_data.thread_count := thread_count
  shared_data.stop_condition := 0

  if queue_init(shared_data.rows_queue) fails do
    print "Error: could not initialize queue"
    return ERR_QUEUE_INIT
  end if

  if semaphore_init(shared_data.can_get_working_row, value: 0) fails do
    print "Error: could not initialize queue semaphore"
    return ERR_CONSUME_SEM_INIT
  end if

  if mutex_init(shared_data.can_access_equilibrated) fails do
    print "Error: could not initialize mutex"
    return ERR_EQULIBRATED_PLATE_MUTEX_INIT
  end if

  if semaphore_init(shared_data.state_done, value: 0) fails do
    print "Error: could not initialize states semaphore"
    return ERR_STATE_DONE_SEM_INIT
  end if

  return EXIT_SUCCESS
end function


function init_private_data(count, data)
  declare shared_data := cast data to shared_data_t*
  allocate private_data as array of private_data_t with size count

  if private_data is not null then
    for index from 0 to shared_data.thread_count - 1 do
      private_data[index].shared_data := data
    end for
  end if

  return private_data
end function


function create_threads(routine, data)
  declare private_data := cast data to private_data_t*
  declare shared_data := cast private_data[0].shared_data to shared_data_t*

  for index from 0 to shared_data.thread_count - 1 do
    if pthread_create(private_data[index].thread_id, routine, &private_data[index]) fails do
      print "Error: could not create thread", index
      join_threads(index, private_data)
      return ERR_CREATE_THREAD
    end if
  end for

  return EXIT_SUCCESS
end function


function join_threads(count, private_data)
  declare error_count := 0

  for index from 0 to count - 1 do
    if join(private_data[index].thread_id) fails do
      print "Error: could not join thread", index
      increment error_count
    end if
  end for

  return error_count
end function


function destroy_shared_data(shared_data)
  queue_destroy(shared_data.rows_queue)
  semaphore_destroy(shared_data.can_get_working_row)
  mutex_destroy(shared_data.can_access_equilibrated)
  semaphore_destroy(shared_data.state_done)
end function
