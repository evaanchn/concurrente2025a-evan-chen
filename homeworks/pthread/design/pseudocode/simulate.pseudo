function equilibrate_plate(job, plate_number, private_data)
  // Set up working data structures
  declare curr_plate := job.plates[plate_number]
  declare shared_data := private_data.shared_data
  declare plate_matrix := curr_plate.plate_matrix

  // Precompute update constants for this plate
  declare diff_times_interval := curr_plate.thermal_diffusivity * curr_plate.interval_duration
  declare cell_area := curr_plate.cells_dimension * curr_plate.cells_dimension
  shared_data.mult_constant := diff_times_interval / cell_area

  // Share plate matrix and epsilon with threads
  shared_data.plate_matrix := plate_matrix
  shared_data.epsilon := curr_plate.epsilon
  shared_data.equilibrated_plate := true

  // Start equilibrium loop
  while true do
    // Copy current matrix values to auxiliary matrix for comparison
    set_auxiliary(plate_matrix)

    // Assign rows to worker threads
    for row from 1 to plate_matrix.rows - 2 do
      queue_enqueue(shared_data.rows_queue, row)
      signal(shared_data.can_get_working_row)
    end for

    // Wait for rows to be processed
    for row from 1 to plate_matrix.rows - 2 do
      wait(shared_data.state_done)
    end for

    // Advance simulation step for plate
    curr_plate.k_states := curr_plate.k_states + 1

    // Check if the plate has reached equilibrium
    declare equilibrated_plate := shared_data.equilibrated_plate

    if NOT equilibrated_plate do
      shared_data.equilibrated_plate := true  // Reset for next iteration
    else
      break  // Stop if equilibrated
    end if
  end while

  return SUCCESS
end function
