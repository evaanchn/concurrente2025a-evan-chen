= Design of solution
:experimental:
:nofooter:
:source-highlighter: highlightjs
:sectnums:
:stem: latexmath
:toc:
:xrefstyle: short

[[analysis]]
== Initial Analysis (Brainstorm)
Two options were proposed for the implementation of a dynamic map: the get-next-row approach and the producer-consumer alternative. I decided to try the latter, given the potential it had. This involved the inclusion of a thread safe queue and coordination between the main thread and worker threads in a thread team.

The idea is to use the same thread team to equilibrate every plate in the job, each one obtaining a row number from the queue to simulate the heat transfer process. The main thread would take on the role of producer, responsible of sending the row numbers into the queue, as well as the stop conditions to halt and join the threads.

[[object_design]]
== Object-oriented design

<<class_diagram>> shows the updated class diagram.

[#class_diagram]
.UML class diagram for the program
image::heat_simul_uml.svg[align="center"]

[[concurrent_design]]
== Concurrent Design
=== Producer-consumer design
<<prodcons>> shows the design of the production line, using `plate001` as an example, and 4 threads as consumers. Note that the main thread enqueues row numbers 1, 2, and 3, the only working rows from the total 5, and signals the worker threads that there is an element to dequeue.

[#prodcons]
.Production line design
image::prod_cons_design.svg[align="center"]

[[threads_pseudo]]
== Pseudocode
=== Private data and shared data
Functions related to initializing, using, and destroying private and shared data structs can be found in threads.c.

[source,delphi]
----
include::pseudocode/threads.pseudo[]
----

=== Main thread procedure: equilibrate_plate()
Main thread first updates the plate-related data in the shared data struct, and then enters the loop to equilibrate said plate. It enqueues the valid rows so workers can simulate them, waits for the results to come in, and evaluates if the plate is equilibrated, after resetting the flag. If so, it breaks from the loop to move on to the next plate.

[source,delphi]
----
include::pseudocode/simulate.pseudo[]
----

=== Worker thread: equilibrate_row()
Each worker thread in the team will execute the `equilibrate_row()` procedure, with an infinite loop that only ends if the thread consumes the stop condition (0). If the consumed value is a valid row, it will go through every single cell in the row and simulate the heat transfer procedure. At the end, it does and AND operation with the equilibrated_plate flag and signals the state_done semaphore to tell main thread that the row was done.

[source,delphi]
----
include::pseudocode/equilibrate_row.pseudo[]
----

[#results]
== Results Analysis
The results were not really positive, as one would predict given the nature of the problem. Durations for each simulation with the same plate varied, given that the dynamic map approach implies the worker threads get assigned units at random, and also complete them at random times.

On average, the simulations with this map type resulted in longer execution times than with the static map version, and only minimally faster than the serial version.