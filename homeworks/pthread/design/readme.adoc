= Design of solution
:experimental:
:nofooter:
:source-highlighter: highlightjs
:sectnums:
:stem: latexmath
:toc:
:xrefstyle: short

[[analysis]]
== Initial Analysis (Brainstorm)

I first tried to identify where the program could use threads. The initial and final stages of the simulation were discarded, given that reading from and writing to files required order. This meant that only after setting the job and plates, during the actual simulation, could threads be implemented.

With this in mind, and in consideration of the suggestion about preferring conditional safety over concurrency control, I opted for dividing plates into different row sections, and then assigning them to threads. Thread creation would happen before each state commenced, and they would be joined once they finished their section.

<<concurrency_brainstorm>> is an informal visualization of the initial idea for adding concurrency to the simulation.

[#concurrency_brainstorm]
.Idea for concurrency
image::concurrency_brainstorm.svg[align="center"]

[[object_design]]
== Object-oriented design

Based on the previous analysis, I came to the conclusion that each worker of the thread team had to have access to shared variables like the plate matrix that was being worked on, the epsilon (to compare differences with), the multiplication constant in the heat transfer formula, and the total amount of threads.

For private data, each thread had a thread id, a starting row and an ending row (inclusive), limiting their access to the matrices, a flag to indicate if their section was equilibrated (each difference is less than epsilon), and a pointer to the shared data.

Finally, some threads manipulation procedures were needed: one to create and set each element of an array of private data, another to create the threads, one to join, and a last one to calculate the intervals of each section.

<<class_diagram>> shows the two new structs added to this concurrent  version: private_data and shared_data. 
[#class_diagram]
.UML class diagram for the program
image::heat_simul_uml.svg[align="center"]

[[concurrent_design]]
== Concurrent Design
=== Memory distribution
<<distribution_example>> is an example of how rows would be distributed for a matrix with 6 rows. Excluding the first and last row, we have 4 rows to evaluate. If two threads were solicited, then each would take half of the plate: upper two rows (1-2) and bottom two (3-4). Note that thread_id was not included in this visualization.

[#distribution_example]
.Example of distributions
image::concurrency_visualization.svg[align="center"]

Contrastingly, if three threads were solicited in the exec command, the first two rows would be in charge of rows 1 and 2 respectively, while the last one would cover 3 and 4. If 4 or more threads were specified, only 4 threads would work on the plate, with one row assigned to each.

[[threads_pseudo]]
== Pseudocode
=== Changes to simulation
First of all, the simulation-related procedure with the most changes was equilibrate_plate(), which now received an extra parameter thread_count. It is in charge of setting private and shared data, before actually simulating the plate. The pseudocode can be found below

[source,delphi]
----
include::pseudocode/simulate.pseudo[]
----

=== Thread related
The following pseudocode is related to the described threads manipulation procedures.

[source,delphi]
----
include::pseudocode/threads.pseudo[]
----

=== Equilibrate rows
Finally, we can look at the procedure called by each thread, which is in charge of simulating the heat transfer of a designated section in the plate, and determines if said area was equilibrated. This procedure takes update_plate()'s place in the plates.c file.

[source,delphi]
----
include::pseudocode/equilibrate_rows.pseudo[]
----
