= Design of solution
:experimental:
:nofooter:
:source-highlighter: highlightjs
:sectnums:
:stem: latexmath
:toc:
:xrefstyle: short

[[analysis]]
== Analysis

After analyzing the problem, I tried to divide the program into 3 phases: input, simulation(processing), and output, each with their related subjects (execution command, job file, etc.). From these on out, possible subroutines were planned out to carry out each phase's tasks, with corresponding structs to store subject's data. A diagram of the described analysis can be found in 


[#breakdown]
.Breakdown of problem and possible subroutines
image::breakdown.svg[align="center"]

Note that the execution command sends arguments into the program to process, which is where the job file to process is indicated. The .txt job file is then read to extract plate file names (.bin) and the related information for their simulation. At this point, plates of type struct plate_t are created to store the aforementioned information, and until it is the plate's turn to go throught the simulation that the .bin file is opened and read, creating plate matrices.

After reaching equilibrium, a separate file is created to report the temperatures of the plate (Updated Plate), with the number of states that it took in the file name. A final report in .tsv is also created after completing the job (simulating all plates), stored in the same directory as the job.

[[data_structures]]
== Data structures
Two main data structures were used in this solution. For instance, job_t is a dynamic array that holds plate_t structs, which in turn contain a plate_matrix_t struct that holds two matrices of doubles: matrix and auxiliary_matrix. The former holds new temperatures while the latter holds current ones, switching before updating temperatures.

Below is an informal drawing of the described design.

[#data_structures_drawing]
.Data structures represented
image::data_structures.svg[align="center"]

[[object_design]]
== Object-oriented design

After the breakdown, the brainstormed subroutines were divided into different categories, some with structs (job_t, plate_t, and plate_matrix_t). The struct plate_matrix_t was thought up to better divide operations related with the process of simulating temperature changes and the actions before and after the simulation (which will be related to the plate_t struct). 

<<class_diagram>> shows the relationship in the division. Note that arrows point to files included, with a blank source rombus meaning aggregation, and filled in source rombuses meaning composition. For the effects of this diagram, files will be considered classes. Names ending in "_t" indicate structs, with attributes listed with "-", and related functions listed with "+". *simulation* and *common* are the only files without struct definitions, not to mention the *main* file, which runs the simulate() procedure.

[#class_diagram]
.UML class diagram for the program
image::heat_simul_uml.svg[align="center"]


[[procedural_design]]
== Procedural design
=== Flowcharts
The main procedures entail the processing of the execution command and the main algorithm of the program: simulate(). Flowcharts of both can be appreciated in <<main_procedures>>.

[#main_procedures]
.Main procedures of the program
image::flowcharts/main_procedures.svg[align="center"]

Set functions are those in charge of creating and preparing jobs and plates. Both take information from files and store them in the structs created (of type job_t and plate_t). Notice that in <<set_functions>>, two of the main set functions are represented in flowcharts.

[#set_functions]
.Set functions
image::flowcharts/set_functions.svg[align="center"]

Update functions are in charge of simulating the plate's transformations between every state, as well as the writing of these files in binary once they have reached equilibrium. In <<update_functions>>, the flowcharts of the three main update procedures show the sequence of steps to achieve their goal.

[#update_functions]
.Update functions
image::flowcharts/update_functions.svg[align="center"]

The procedure to create a .tsv report of the simulated job, report_results(), goes through all of the registered plates, formats their information into a tab separated string and writes the result in a file with the same name as the job.

[#report_results]
.Report results function
image::flowcharts/report_results.svg[align="center"]

[#pseudocode]
=== Pseudocode
The pseudocode for each file of the program will be presented in reverse usage order, meaning that subroutines for "classes" that are agregated will be described first, building up to the main procedures.

==== common
A section for common code was added to store string manipulation functions like build_file_path() (concatenates file name to directory), extract_directory(), extract_file_name(), and modify_extension() (returns modified extension of given file path). These were thought up to properly control where to find files to read or write in, for example to store simulated plates in the source directory, or writing .tsv reports of simulations. ChatGPT's assistance was needed for this part. Self-written pseudocode for each procedure:
[source,delphi]
----
include::pseudocode/common.pseudo[]
----

==== plate_matrix
The subroutines associated to the plate_matrix_t struct involve allocation and deallocation of memory for the matrices, the management of the auxiliary matrix (switching with main matrix before each temperature update), and the application of the formula for calculating a cell's new temperature (update_cell(), most notable subroutine of this section).

[source,delphi]
----
include::pseudocode/plate_matrix.pseudo[]
----

==== plate
Here, subroutines related to the managing and updating of the matrices in plate matrix, and the generation of an updated matrix file can be found.

[source,delphi]
----
include::pseudocode/plate.pseudo[]
----

==== job
In this section, apart from the report job results function, subroutines to control the job_t structure, a dynamic array, can be found. The most notable procedures are the aforementioned report_results() and set_job(), which reads the job file and sets up plate_t structs to store.

[source,delphi]
----
include::pseudocode/job.pseudo[]
----

==== simulation
The procedure simulate() is where everything before is integrated to fully encompass the tasks of all three phases (input, processing, output). The pseudocode for said subroutine is the following.

[source,delphi]
----
include::pseudocode/simulation.pseudo[]
----

==== main
The main procedure is in charge of processing the arguments received in the execution command, and notify any anomalies related to the input to the user. Then, it calls simulate() in simulation.c and later returns the error code returned by said procedure. The pseudocode for main() can be found below.


[source,delphi]
----
include::pseudocode/main.pseudo[]
----

Note that the thread_count part will be implemented in the second part of this homework.

