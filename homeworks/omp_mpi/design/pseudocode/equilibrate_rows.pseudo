function equilibrate_rows(data)
  declare private_data := cast data to private_data_t*
  declare shared_data := private_data.shared_data
  declare plate_matrix := shared_data.plate_matrix

  declare starting_row := private_data.starting_row
  declare ending_row := private_data.ending_row

  for row from starting_row to ending_row - 1 do
    for col from 1 to plate_matrix.cols - 2 do
      update_cell(plate_matrix, row, col, shared_data.mult_constant)

      declare index := row * plate_matrix.cols + col
      declare new_temp := plate_matrix.matrix[index]
      declare old_temp := plate_matrix.auxiliary_matrix[index]

      declare difference := abs(new_temp - old_temp)

      if difference > shared_data.epsilon do
        private_data.equilibrated := false
      end if
    end for
  end for

  return null
end function



function equilibrate_plate_concurrent(data)
  declare private_data := cast data to private_data_t*
  declare shared_data := private_data.shared_data
  declare plate_matrix := shared_data.plate_matrix

  loop forever
    // Assume the section is equilibrated for this iteration
    private_data.equilibrated := true

    equilibrate_rows(data)

    // Combine results across threads
    lock(shared_data.can_access_equilibrated)
      shared_data.equilibrated_plate := shared_data.equilibrated_plate AND private_data.equilibrated
    unlock(shared_data.can_access_equilibrated)

    // Wait for all threads to finish updating cells
    declare result := wait(shared_data.can_continue1)
    // Last thread increments states and sets up auxiliary matrix
    if result is LAST_THREAD then
      increment shared_data.k_states
      set_auxiliary(plate_matrix)
    end if

    wait(shared_data.can_continue2)

    // Check if plate was equilibrated
    lock(shared_data.can_access_equilibrated)
      declare done := shared_data.equilibrated_plate
    unlock(shared_data.can_access_equilibrate)

    // Exit if plate equilibrated
    if done then
      break
    end if

    // Last thread resets equilibrium flag before next iteration
    if wait(shared_data.can_continue1) is LAST_THREAD do
      lock(shared_data.can_access_equilibrated)
        shared_data.equilibrated_plate := true
      unlock(shared_data.can_access_equilibrated)
    end if

    // Wait again to avoid premature access to the new flag value
    wait(shared_data.can_continue2)
  end loop

  return null
end function
